<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · Euler1D</title><meta name="title" content="Function Reference · Euler1D"/><meta property="og:title" content="Function Reference · Euler1D"/><meta property="twitter:title" content="Function Reference · Euler1D"/><meta name="description" content="Documentation for Euler1D."/><meta property="og:description" content="Documentation for Euler1D."/><meta property="twitter:description" content="Documentation for Euler1D."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Euler1D</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Euler1D</a></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li><a class="tocitem" href="../Methodology/">Methodology</a></li><li class="is-active"><a class="tocitem" href>Function Reference</a><ul class="internal"><li><a class="tocitem" href="#Problem-Configuration"><span>Problem Configuration</span></a></li><li><a class="tocitem" href="#Timestepping"><span>Timestepping</span></a></li><li><a class="tocitem" href="#Equation-of-State"><span>Equation of State</span></a></li><li><a class="tocitem" href="#Artificial-Dissipation"><span>Artificial Dissipation</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Governing-Equations"><span>Governing Equations</span></a></li><li><a class="tocitem" href="#Internal-Functions"><span>Internal Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fergu/Euler1D.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fergu/Euler1D.jl/blob/main/docs/src/FunctionReference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-Reference"><a class="docs-heading-anchor" href="#Function-Reference">Function Reference</a><a id="Function-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Reference" title="Permalink"></a></h1><h2 id="Problem-Configuration"><a class="docs-heading-anchor" href="#Problem-Configuration">Problem Configuration</a><a id="Problem-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Configuration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.DefaultSimulationParameters" href="#Euler1D.DefaultSimulationParameters"><code>Euler1D.DefaultSimulationParameters</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DefaultSimulationParameters()</code></pre><p>Return a set of default parameters for a simulation.</p><p><strong>Returns</strong></p><p>A <code>Dict{String, Any}</code> with default parameters for a simulation. </p><p><strong>Notes</strong></p><ul><li>Keys with a value of <code>nothing</code> must be set before using this dictionary to initialize a simulation. This is done instead of providing a default function to avoid the possibility of accidentally initializing a simulation with unintended initial conditions.</li></ul><p><strong>Parameters</strong></p><ul><li><code>start_time</code>: The initial time of the simulation. (Unit: s; Default: 0.0)</li><li><code>end_time</code>: The final time of the simulation. (Unit: s; Default: 1.0)</li><li><code>start_position</code>: The position of the left side of the domain. (Unit: m; Default: 0.0)</li><li><code>end_position</code>: The position of the right side of the domain. (Unit: m; Default: 1.0)</li><li><code>number_of_zones</code>: The number of zones to divide the domain into. (Unit: ⋅; Default: 1000)</li><li><code>CFL</code>: The CFL number to use. (Unit: ⋅; Default: 0.2)</li><li><code>artificial_viscosity_coefficient</code>: The coefficient to use for artificial viscosity. (Unit: ⋅; Default: 1e0)</li><li><code>artificial_conductivity_coefficient</code>: The coefficient to use for artificial conductivity. (Unit: ⋅; Default: 1e-2)</li><li><code>min_timestep</code>: The minimum allowable timestep size. Simulation will halt if timestep falls below this value. (Unit: s; Default: 1e-7)</li><li><code>max_cycles</code>: The maximum number of cycles to perform. Simulation will halt if more than this many timesteps are taken. (Unit: ⋅; Default: 1e6)</li><li><code>init_density_function</code>: A <code>Function</code> that returns the initial density as a function of position <code>x</code>. (Unit: kg/m³; Default: <code>nothing</code>, must be user-supplied)</li><li><code>init_velocity_function</code>: A <code>Function</code> that returns the initial velocity as a function of position <code>x</code>. (Unit: m/s; Default: <code>nothing</code>, must be user-supplied)</li><li><code>init_pressure_function</code>: A <code>Function</code> that returns the initial pressure as a function of position <code>x</code>. (Unit: N/m²; Default: <code>nothing</code>, must be user-supplied)</li><li><code>init_gamma_function</code>: A <code>Function</code> that returns the ratio of specific heats as a function of position <code>x</code>. (Unit: ⋅; Default: <code>nothing</code>, must be user-supplied)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Configuration.jl#L155-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.InitializeSimulation" href="#Euler1D.InitializeSimulation"><code>Euler1D.InitializeSimulation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InitializeSimulation( parameters::Dict{String, Any} )</code></pre><p>Initialize a simulation with the parameters provided by <code>parameters</code>. A default set of <code>parameters</code> can be returned from the <a href="#Euler1D.DefaultSimulationParameters"><code>DefaultSimulationParameters()</code></a> function.</p><p><strong>Returns</strong></p><p>A struct of type <code>Simulation{T}</code> that describes the current simulation state. The type <code>T</code> is determined by the type of the members of <code>parameters</code>.</p><p><strong>Notes</strong></p><ul><li>This function performs some basic sanity checking on input parameters such as ensuring that <code>end_time &gt; start_time</code> or <code>end_position &gt; start_position</code>, and will raise an error if any of these checks fail.</li><li>A warning will be raised if any keys in the dictionary are unused, but this will not halt execution.</li><li>This function will not warn about any potential issues with problem configuration or potential stability issues.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Configuration.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.UpdateSimulationState!" href="#Euler1D.UpdateSimulationState!"><code>Euler1D.UpdateSimulationState!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UpdateSimulationState!( state::Simulation{T}, gamma::Function, density::Function, velocity::Function, pressure::Function ) where { T &lt;: AbstractFloat }</code></pre><p>Update the simulation state using the supplied functions to define a new state. See Notes for information about the expected signature of the functions.</p><p><strong>Returns</strong></p><p><code>nothing</code>. Updates the <code>state</code> input in-place.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <code>Simulation{T}</code> representing the simulation state to be updated</li><li><code>gamma</code>: A <code>Function</code> that returns the new values of the ratio of specific heats, gamma</li><li><code>density</code>: A <code>Function</code> that returns the new values of the density</li><li><code>velocity</code>: A <code>Function</code> that returns the new values of velocity</li><li><code>pressure</code>: A <code>Function</code> that returns the new values of pressure</li></ul><p><strong>Notes</strong></p><p>Unlike the functions used in initial problem setup, the functions supplied to <code>UpdateSimulationState</code> have a slightly different expected signature of     ExampleFunction( x::T, oldValue::T ) where { T &lt;: AbstractFloat } where <code>oldValue</code> will be the current value of the state variable at current position <code>x</code> (e.g., the previous value of pressure).</p><p><strong>Side Effects</strong></p><ul><li>Updates the values stored in the vectors for <code>state.gamma</code>, <code>state.mass</code>, <code>state.velocity</code>, <code>state.intenergy</code>, and fields derived from the equation of state in-place.</li></ul><div class="admonition is-warning" id="Warning-7996f190097fcb0f"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-7996f190097fcb0f" title="Permalink"></a></header><div class="admonition-body"><p>If the <code>density</code> function alters the <code>state.density</code> field (that is, it does not just return <code>oldValue</code>), mass will be added or removed from a given zone to achieve a specified value of <code>density</code> without changing zone size. As a consequence, mass will not be conserved in the system in this case.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Configuration.jl#L119-L144">source</a></section></article><h2 id="Timestepping"><a class="docs-heading-anchor" href="#Timestepping">Timestepping</a><a id="Timestepping-1"></a><a class="docs-heading-anchor-permalink" href="#Timestepping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.AdvanceToTime" href="#Euler1D.AdvanceToTime"><code>Euler1D.AdvanceToTime</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvanceToTime( state::Simulation{T}, stoptime::T, Δt::T; exact::Bool=false ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation with initial state <code>state</code> to a time specified by <code>stoptime</code> with a fixed timestep. </p><p><strong>Returns</strong></p><p>A <code>Simulation{T}</code> representing the state at the end of the final cycle.</p><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the first cycle.</li><li><code>stoptime</code>: The time to advance to. (Unit: s)</li><li><code>Δt</code>: The timestep size. (Unit: s)</li><li><code>exact</code>: If true, try to stop as close as possible to <code>stoptime</code> by adjusting the final timestep size (Default: <code>false</code>)</li></ul><p><strong>Notes</strong></p><ul><li>The current simulation time is determined by the <code>Simulation</code> field <code>state.time</code>. If <code>state.time &gt; stoptime</code>, no steps will be taken.</li><li>This function allocates two <code>deepcopy()</code>s of the input state and returns the copy corresponding to the final state.</li><li>This function simply calls <code>AdvanceOneCycle!</code> repeatedly until the simulation time reaches <code>stoptime</code>. The primary advantage to using this function as opposed to <a href="#Euler1D.AdvanceOneCycle"><code>AdvanceOneCycle()</code></a> or <a href="#Euler1D.AdvanceNCycles"><code>AdvanceNCycles()</code></a> is that various backing arrays are pre-allocated to improve speed.</li><li>If <code>exact=true</code>, the timestep of the final cycle is adjusted so that the time of the final state is as close as possible to <code>stoptime</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Timestepping.jl#L1-L20">source</a></section><section><div><pre><code class="language-julia hljs">AdvanceToTime( state::Simulation{T}, stoptime::T; exact::Bool=false ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation with initial state <code>state</code> to a time specified by <code>stoptime</code> with a variable timestep. </p><p><strong>Returns</strong></p><p>A <code>Simulation{T}</code> representing the state at the end of the final cycle</p><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the first cycle.</li><li><code>stoptime</code>: The time to advance to. (Unit: s)</li><li><code>exact</code>: If true, try to stop as close as possible to <code>stoptime</code> by adjusting the final timestep size (Default: false)</li></ul><p><strong>Notes</strong></p><ul><li>The current simulation time is determined by the <code>Simulation</code> field <code>state.time</code>. If <code>state.time &gt; stoptime</code>, no steps will be taken.</li><li>This function allocates two <code>deepcopy()</code>s of the input state and returns the copy corresponding to the final state.</li><li>This function simply calls <code>AdvanceOneCycle!()</code> repeatedly until the simulation time reaches <code>stoptime</code>. The primary advantage to using this function as opposed to <a href="#Euler1D.AdvanceOneCycle"><code>AdvanceOneCycle()</code></a> or <a href="#Euler1D.AdvanceNCycles"><code>AdvanceNCycles()</code></a> is that various backing arrays are pre-allocated to improve speed.</li><li>The timestep size, Δt, is determined for each cycle based on the minimum time for an acoustic wave to traverse a zone. See the documentation for <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details. </li><li>If <code>exact=true</code>, the timestep of the final cycle is adjusted so that the time of the final state is as close as possible to <code>stoptime</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Timestepping.jl#L39-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.AdvanceOneCycle" href="#Euler1D.AdvanceOneCycle"><code>Euler1D.AdvanceOneCycle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvanceOneCycle( state::Simulation{T}, Δt::T ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by one cycle with a timestep of Δt.</p><p><strong>Returns</strong></p><p>A <code>Simulation{T}</code> representing the state at the end of the cycle</p><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the cycle.</li><li><code>Δt</code>: The size of the time step. (Unit: s)</li></ul><p><strong>Notes</strong></p><ul><li>This function allocates a <code>deepcopy()</code> of the input state. The copy is modified and returned from this function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Timestepping.jl#L122-L136">source</a></section><section><div><pre><code class="language-julia hljs">AdvanceOneCycle( state::Simulation{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by one cycle. </p><p><strong>Returns</strong></p><ul><li>A <code>Simulation{T}</code> representing the state at the end of the cycle</li></ul><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the cycle</li></ul><p><strong>Notes</strong></p><ul><li>This function allocates a <code>deepcopy()</code> of the input state and returns the copy.</li><li>The timestep size, Δt, is determined based on the minimum time for an acoustic wave to traverse a zone. See <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Timestepping.jl#L143-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.AdvanceOneCycle!" href="#Euler1D.AdvanceOneCycle!"><code>Euler1D.AdvanceOneCycle!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvanceOneCycle!( output::Simulation{T}, input::Simulation{T}, Δt::T ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by one cycle with a timestep of Δt.</p><p><strong>Returns</strong></p><p><code>nothing</code>. Modifies <code>output</code> in-place.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: A <code>Simulation{T}</code> that will represent the output state. This will be modified by the function to represent the simulation state after advancing one cycle.</li><li><code>input</code>: A <code>Simulation{T}</code> that represents the simulation state at the start of the cycle.</li><li><code>Δt</code>: The size of the time step. (Unit: s)</li></ul><p><strong>Side Effects</strong></p><ul><li>All fields of <code>output</code> are modified in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Timestepping.jl#L79-L94">source</a></section><section><div><pre><code class="language-julia hljs">AdvanceOneCycle!( output::Simulation{T}, input::Simulation{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by one cycle. </p><p><strong>Returns</strong></p><p><code>nothing</code>. Modifies <code>output</code> in-place.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: A <code>Simulation{T}</code> that will represent the output state. This will be modified by the function to represent the simulation state after advancing one cycle.</li><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the cycle</li></ul><p><strong>Notes</strong></p><ul><li>The timestep size, Δt, is determined based on the minimum time for an acoustic wave to traverse a zone. See <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details.</li></ul><p><strong>Side Effects</strong></p><ul><li>All fields of <code>output</code> are modified in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Timestepping.jl#L99-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.AdvanceNCycles" href="#Euler1D.AdvanceNCycles"><code>Euler1D.AdvanceNCycles</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvanceNCycles( state::Simulation{T}, ncycles::UInt, Δt::T ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by <code>ncycles</code> cycles with a fixed timestep.</p><p><strong>Returns</strong></p><ul><li>A <code>Simulation{T}</code> representing the state at the end of the final cycle</li></ul><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the first cycle.</li><li><code>ncycles</code>: The number of cycles to advance.</li><li><code>Δt</code>: The size of the time step. (Unit: s)</li></ul><p><strong>Notes</strong></p><ul><li>This function allocates two <code>deepcopy()</code>s of the input state and returns the copy corresponding to the final state.</li><li>This function calls <a href="#Euler1D.AdvanceOneCycle!"><code>AdvanceOneCycle!()</code></a> a total of <code>ncycles</code> times to advance the simulation. The primary advantage to using this function as opposed to <a href="#Euler1D.AdvanceOneCycle"><code>AdvanceOneCycle()</code></a> if the number of cycles to advance is known is that various backing arrays are pre-allocated to improve speed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Timestepping.jl#L164-L180">source</a></section><section><div><pre><code class="language-julia hljs">AdvanceNCycles( state::Simulation{T}, ncycles::UInt ) where { T &lt;: AbstractFloat }</code></pre><p>Advance the simulation by <code>ncycles</code> cycles with a variable timestep. </p><p><strong>Returns</strong></p><ul><li>A <code>Simulation{T}</code> representing the state at the end of the final cycle</li></ul><p><strong>Arguments</strong></p><ul><li><code>input</code>: A <code>Simulation{T}</code> representing the simulation state at the start of the first cycle.</li><li><code>ncycles</code>: The number of cycles to advance. (Unit: ⋅)</li></ul><p><strong>Notes</strong></p><ul><li>This function allocates two <code>deepcopy()</code>s of the input state and returns the copy corresponding to the final state.</li><li>This function calls <a href="#Euler1D.AdvanceOneCycle!"><code>AdvanceOneCycle!()</code></a> a total of <code>ncycles</code> times to advance the simulation. The primary advantage to using this function as opposed to <a href="#Euler1D.AdvanceOneCycle"><code>AdvanceOneCycle()</code></a> if the number of cycles to advance is known is that various backing arrays are pre-allocated to improve speed.</li><li>The timestep size, Δt, is determined based on the minimum time for an acoustic wave to traverse a zone. See <a href="#Euler1D.CalculateTimestepSize"><code>CalculateTimestepSize()</code></a> for further details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Timestepping.jl#L197-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.CalculateTimestepSize" href="#Euler1D.CalculateTimestepSize"><code>Euler1D.CalculateTimestepSize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CalculateTimestepSize( state::Simulation{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Compute an automatic timestep size for the next simulation cycle based on the current simulation state. See the Notes section for details on how the timestep is determined.</p><p><strong>Returns</strong></p><ul><li>A scalar of type <code>T</code> representing the timestep size for the next cycle based on the current simulation state.</li></ul><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <code>Simulation{T}</code> representing the problem state.</li></ul><p><strong>Notes</strong></p><ul><li>For each zone, the local speed of sound is computed according to <code>c = √( γ P / ρ )</code>, where γ, P, and ρ are the ratio of specific heats, the pressure, and the density of the gas in that zone.</li><li>The time for an acoustic wave to traverse a zone with length <code>Δx</code> is computed as <code>t = Δx / c</code>.</li><li>The minimum traversal time for all zones is multiplied by the user-specified CFL number to obtain the timestep size.</li><li>Sanity checking for negative zone sizes and small timesteps is performed to detect problem instability.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Timestepping.jl#L232-L248">source</a></section></article><h2 id="Equation-of-State"><a class="docs-heading-anchor" href="#Equation-of-State">Equation of State</a><a id="Equation-of-State-1"></a><a class="docs-heading-anchor-permalink" href="#Equation-of-State" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.EOS_Density" href="#Euler1D.EOS_Density"><code>Euler1D.EOS_Density</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EOS_Density( mass::T, Δx::T ) where { T &lt;: AbstractFloat } = mass / Δx</code></pre><p>Compute the density of the fluid in a zone.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the density of a zone.</p><p><strong>Arguments</strong></p><ul><li><code>mass</code>: The total mass contained within the zone. (Unit: kg)</li><li><code>Δx</code>: The size of the zone. (Unit: m)</li></ul><p><strong>Notes</strong></p><p>Density is calculated as:     ρ = mass / Δx As this is the physical definition of density, this calculation does not assume any particular equation of state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/EquationOfState.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.EOS_Pressure" href="#Euler1D.EOS_Pressure"><code>Euler1D.EOS_Pressure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EOS_Pressure( γ::T, ρ::T, e::T ) where { T &lt;: AbstractFloat }
EOS_Pressure( γ::T, mass::T, Δx::T, e::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the pressure of a zone using an ideal gas equation of state.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the pressure within the zone.</p><p><strong>Arguments</strong></p><ul><li><code>γ</code>: The ratio of specific heats of the fluid in the zone. (Unit: ⋅)</li><li><code>ρ</code>: The density of the zone. (Unit: kg/m³)</li><li><code>mass</code>: The total mass contained within the zone. (Unit: kg)</li><li><code>Δx</code>: The size of the zone. (Unit: m)</li><li><code>e</code>: The internal energy per unit mass of the zone. (Unit: m²/s²)</li></ul><p><strong>Notes</strong></p><p>The pressure is calculated as:     P = ( γ - 1 ) * ρ * e The four-parameter version of this function computes density using <a href="#Euler1D.EOS_Density"><code>EOS_Density()</code></a>. See the documentation for that function for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/EquationOfState.jl#L43-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.EOS_SpeedOfSound" href="#Euler1D.EOS_SpeedOfSound"><code>Euler1D.EOS_SpeedOfSound</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EOS_SpeedOfSound( γ::T, P::T, ρ::T ) where { T &lt;: AbstractFloat }
EOS_SpeedOfSound( γ::T, e::T, mass::T, Δx::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the speed of sound in a zone using an ideal gas equation of state.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the speed of sound in the zone.</p><p><strong>Arguments</strong></p><ul><li><code>γ</code>: The ratio of specific heats in the zone. (Unit: ⋅)</li><li><code>e</code>: The internal energy per unit mass in the zone. (Unit: m²/s²)</li><li><code>P</code>: The pressure in the zone. (Unit: kg/(m⋅s²))</li><li><code>ρ</code>: The density of the fluid in the zone. (Unit: kg/m³)</li><li><code>mass</code>: The mass contained in the zone. (Unit: kg)</li><li><code>Δx</code>: The length of the zone. (Unit: m)</li></ul><p><strong>Notes</strong></p><p>The speed of sound is calculated as:     c = √( γ * P / ρ ) The four-parameter version of this function computes density using <a href="#Euler1D.EOS_Density"><code>EOS_Density()</code></a> and pressure using <a href="#Euler1D.EOS_Pressure"><code>EOS_Pressure()</code></a>. See the documentation of those functions for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/EquationOfState.jl#L90-L111">source</a></section></article><h2 id="Artificial-Dissipation"><a class="docs-heading-anchor" href="#Artificial-Dissipation">Artificial Dissipation</a><a id="Artificial-Dissipation-1"></a><a class="docs-heading-anchor-permalink" href="#Artificial-Dissipation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.artificial_viscosity" href="#Euler1D.artificial_viscosity"><code>Euler1D.artificial_viscosity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">artificial_viscosity( Cᵥ::T, c::T, ρ::T, Δx::T, u₋::T, u₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute an artificial viscosity within a zone. </p><p><strong>Returns</strong></p><p>A value of type <code>T</code> representing the value of the artificial viscosity.</p><p><strong>Arguments</strong></p><ul><li><code>Cᵥ</code>: An O(1) coefficient to control the strength of the artificial viscosity. (Unit: ⋅)</li><li><code>c</code>: The speed of sound in the zone. (Unit: m/s)</li><li><code>ρ</code>: The density of the zone. (Unit: kg/m³)</li><li><code>Δx</code>: The length of the zone. (Unit: m)</li><li><code>u</code>: The velocity of the zone boundaries, with superscripts - and + referring to the left and right boundaries, respectively. (Unit: m/s)</li></ul><p><strong>Notes</strong></p><ul><li>This artificial viscosity is based on the method described by Wilkins (1980), which in turn relies upon the methods of Von Neumann and Richtmyer (1950) and Landschoff (1955). This functions by adding the artificial viscosity computed by this function to the pressure field during the <a href="#Euler1D.Momentum!"><code>Momentum!()</code></a> and <a href="#Euler1D.Energy!"><code>Energy!()</code></a> updates.</li><li>The calculation of artificial viscosity requires a gradient of velocity, ∂u/∂x. This is computed using <a href="#Euler1D.∂∂x_ZoneEdgeToZoneCenter"><code>∂∂x_ZoneEdgeToZoneCenter()</code></a>. See the documentation of that function for details on the numerical method used for gradient calculation.</li><li>This function returns zero if <code>∂u/∂x &gt; 0</code>, which will be the case for regions where the flow is expanding. This is done to restrict artificial viscosity only to regions of compression.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/ArtificialDissipation.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.artificial_conductivity" href="#Euler1D.artificial_conductivity"><code>Euler1D.artificial_conductivity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">artificial_conductivity( Cₖ::T, u::T, c₋::T, e₋::T, Δx₋::T, c₊::T, e₊::T, Δx₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute an artificial flux of internal energy across a zone interface.</p><p><strong>Returns</strong></p><p>A value of type <code>T</code> representing the artifical flux of internal energy across a zone boundary.</p><p><strong>Arguments</strong></p><ul><li><code>Cₖ</code>: An O(1) coefficient to control the strength of the artificial conductivity. (Unit: ⋅)</li><li><code>u</code>: The velocity of the zone interface. (Unit: m/s)</li><li><code>c</code>: The speed of sound, where superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m/s)</li><li><code>e</code>: The internal energy per unit mass. Superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m²/s²)</li><li><code>Δx</code>: Length of the zone. Superscript - and + refer to the zones to the left and right of the zone interface, respectively. (Unit: m)</li></ul><p><strong>Notes</strong></p><p>The artificial conductivity is modeled as a Fickian diffusivity. That is, the flux of energy across a zone boundary, fₑ, is described by     fₑ = -κ ∂e/∂x where e is the internal energy per unit mass and κ is the (artificial) conductivity coefficient. The gradient of internal energy is treated with a simple forward finite difference. The artificial conductivity coefficient is modeled as     κ = Cₖ * cₘ * Δx where</p><ul><li>Cₖ an O(1) coefficient.</li><li>cₘ  is a characteristic velocity taken to be max(c̄±u, c̄), where c̄=0.5*(c₋+c₊) is the average speed of sound of the two adjacent zones and u is the velocity of the zone interface. </li><li>Δx is the distance between the zone centers</li></ul><p>By convention, this leads to a positive flux if energy is diffusing in the positive x direction, and negative if it is diffusing in the negative x direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/ArtificialDissipation.jl#L54-L80">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.Simulation" href="#Euler1D.Simulation"><code>Euler1D.Simulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Simulation{T}</code></pre><p>A structure containing all the internal variables and arrays used in the simulation.</p><p><strong>Parameters</strong></p><ul><li><code>nzones::Int</code>: The number of zones in the simulation. (Unit: ⋅)</li><li><code>nedges::Int</code>: The number of zone edges in the simulation, equal to <code>nzones + 1</code>. (Unit: ⋅)</li><li><code>CFL::Float64</code>: The CFL number to be used when calculating timesteps. (Unit: ⋅)</li><li><code>t₀::Float64</code>: The initial time of the simulation. (Unit: s)</li><li><code>t₁::Float64</code>: The final time of the simulation. (Unit: s)</li><li><code>Cᵥ::Float64</code>: The coefficient used to scale artificial viscosity. (Unit: ⋅)</li><li><code>Cₖ::Float64</code>: The coefficient used to scale artificial conductivity. (Unit: ⋅)</li><li><code>time::Base.RefValue{T}</code>: The current time of the simulation. (Unit: s)</li><li><code>Δt::Base.RefValue{T}</code>: The size of the timestep taken in the last cycle. (Unit: s)</li><li><code>cycles::Base.RefValue{UInt}</code>: The number of cycles performed so far. (Unit: ⋅)</li><li><code>min_Δt::Float64</code>: The minimum allowable timestep size. Simulation will halt if <code>Δt</code> falls below this value. (Unit: s)</li><li><code>max_cycles::UInt</code>: The maximum number of cycles to perform. Simulation will halt if <code>cycles</code> exceeds this value. (Unit: ⋅)</li><li><code>x::Vector{T}</code>: A vector of locations of zone edges. Increases monotonically. (Unit: m)</li><li><code>Δx::Vector{T}</code>: A vector of the size of each zone. (Unit: m)</li><li><code>gamma::Vector{T}</code>: A vector of the ratio of specific heats inside each zone. (Unit: ⋅)</li><li><code>mass::Vector{T}</code>: A vector of the mass contained within each zone. Assumed constant. (Unit: kg)</li><li><code>density::Vector{T}</code>: A vector of the density of the fluid within each zone. Computed using the equation of state as mass/Δx. (Unit: kg/m³)</li><li><code>velocity::Vector{T}</code>: A vector of velocities of zone edges. (Unit: m/s)</li><li><code>pressure::Vector{T}</code>: A vector of pressures inside each zone. Computed from the equation of state. (Unit: kg/(m⋅s²))</li><li><code>intenergy::Vector{T}</code>: A vector of the internal energy per unit mass of each zone. (Unit: m²/s²)</li><li><code>speedofsound::Vector{T}</code>: A vector of the speed of sound within each zone. Computed from the equation of state. (Unit: m/s)</li><li><code>viscosity::Vector{T}</code>: A vector of the artificial viscosity within each zone, added to the pressure field. See ArtificialDissipation.jl for more information. (Unit: kg/(m⋅s²))</li><li><code>energy_flux::Vector{T}</code>: A vector of fluxes of internal energy per unit mass across each zone boundary. Added to the energy equation as a diffusion term. See ArtificialDissipation.jl for more information. (Unit: m³/s³)</li><li><code>∂u∂t::Vector{T}</code>: A vector of the right hand side of the momentum equation at each zone edge. (Unit: m/s²)</li><li><code>∂e∂t::Vector{T}</code>: A vector of the right hand side of the energy equation within each zone. (Unit: m²/s³)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/Types.jl#L1-L32">source</a></section></article><h2 id="Governing-Equations"><a class="docs-heading-anchor" href="#Governing-Equations">Governing Equations</a><a id="Governing-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Governing-Equations" title="Permalink"></a></h2><div class="admonition is-info" id="Note-adaf0bef1046c13b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-adaf0bef1046c13b" title="Permalink"></a></header><div class="admonition-body"><p>These functions are not intended to be called directly as part of simulation setup. However, as their functionality is central to this package, they are documented here for reference.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.Momentum" href="#Euler1D.Momentum"><code>Euler1D.Momentum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Momentum( ρ₋::T, P₋::T, Δx₋::T, ρ₊::T, P₊::T, Δx₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the right hand side of the momentum equation at a zone interface. See the Notes section for information on the equation being solved.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the rate of change of velocity of a zone interface over time.</p><p><strong>Arguments</strong></p><ul><li><code>ρ</code>: The density of the zone. (Unit: kg/m³)</li><li><code>P</code>: The pressure of the zone (Unit: kg/(m⋅s²))</li><li><code>Δx</code>: The length of the zone. (Unit: m)</li></ul><p>For each of these parameters, a - subscript refers to the zone to the left of the zone interface and a + subscript refers to the zone to the right of the zone interface.</p><p><strong>Notes</strong></p><p>The governing equation solved in this function is:     ∂u/∂t = (1/ρ) * ∂P/∂x Here, ρ is taken to be the average of the densities in the zones to the left and right of the interface, and <code>∂P/∂x</code> is computed using <a href="#Euler1D.∂∂x_ZoneCenterToZoneEdge"><code>∂∂x_ZoneCenterToZoneEdge</code></a>. If using artificial viscosity per the method of Von Neumann and Richtmyer (1950), the artificial viscosity term should be added to the pressure field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/EulerEquations.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.Energy" href="#Euler1D.Energy"><code>Euler1D.Energy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Energy( ρ::T, P::T, Δx::T, u₋::T, u₊::T, q₋::T, q₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the right hand side of the energy equation in a zone. See the Notes section for the specific equations that are solved.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the rate of change of internal energy inside the zone.</p><p><strong>Arguments</strong></p><ul><li><code>ρ</code>: The density of the zone, (Unit: kg/m³)</li><li><code>P</code>: The pressure of the zone, (Unit: kg/(m⋅s²))</li><li><code>Δx</code>: The length of the zone, (Unit: m)</li><li><code>u</code>: The velocity of the zone edges on the (-): left and (+): right of the zone, (Unit: m/s)</li><li><code>q</code>: The (artificial) flux of internal energy across the (-): left and (+): right zone edges, (Unit: m³/s³) </li></ul><p><strong>Notes:</strong></p><p>The governing equation solved in this function is     ∂e/∂t = - ( P / ρ ) * ∂u/∂x + ∑q</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/EulerEquations.jl#L53-L71">source</a></section></article><div class="admonition is-warning" id="Warning-62fa58c9e2edf44f"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-62fa58c9e2edf44f" title="Permalink"></a></header><div class="admonition-body"><p>These functions deal with calculating the rate of change of energy and momentum over the entire simulation domain. They should not be called as part of simulation configuration, but are documented here for completeness.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.Momentum!" href="#Euler1D.Momentum!"><code>Euler1D.Momentum!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Momentum!( output::Simulation{T}, input::Simulation{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the right hand side of the momentum equation for every zone interface. </p><p><strong>Returns</strong></p><p><code>nothing</code>. The <code>output</code> argument is modified in-place.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: A <code>Simulation{T}</code> object representing the output problem state. This argument is modified by the function.</li><li><code>input</code>: A <code>Simulation{T}</code> object representing the input problem state.</li></ul><p><strong>Notes</strong></p><p>This function calls <a href="#Euler1D.Momentum"><code>Momentum()</code></a> to perform the actual calculation. See the documentation of that function for more information. The artificial viscosity term is added to the pressure field during the call to <a href="#Euler1D.Momentum"><code>Momentum()</code></a>, per the artificial viscosity method of Von Neumann and Richtmyer (1950).</p><p><strong>Side Effects</strong></p><ul><li>Modifies the values contained in <code>output.∂u∂t</code> in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/EulerEquations.jl#L28-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.Energy!" href="#Euler1D.Energy!"><code>Euler1D.Energy!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Energy!( output::Simulation{T}, input::Simulation{T} ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the right hand side of the energy equation for every zone. </p><p><strong>Returns</strong></p><p><code>nothing</code>. The <code>output</code> argument is modified in-place.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: A <code>Simulation{T}</code> object representing the output problem state. This argument is modified by this function.</li><li><code>input</code>: A <code>Simulation{T}</code> object representing the input problem state.</li></ul><p><strong>Notes</strong></p><ul><li>This function calls <a href="#Euler1D.Energy"><code>Energy()</code></a> to perform the actual calculation. See the documentation of that function for more information.</li><li>The artificial viscosity term is added to the pressure field during the call to <a href="#Euler1D.Energy"><code>Energy()</code></a>, per the artificial viscosity method of Von Neumann and Richtmyer (1950).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/EulerEquations.jl#L77-L92">source</a></section></article><h2 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h2><div class="admonition is-warning" id="Warning-2ba1a27223eac679"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-2ba1a27223eac679" title="Permalink"></a></header><div class="admonition-body"><p>These functions are internal to <code>Euler1D.jl</code> and are not intended for use in setting up simulations. Their function signatures may change at any time and without notice. The documentation of these functions is primarily included to support documentation of user-facing functionality.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.∂∂x_ZoneCenterToZoneEdge" href="#Euler1D.∂∂x_ZoneCenterToZoneEdge"><code>Euler1D.∂∂x_ZoneCenterToZoneEdge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∂∂x_ZoneCenterToZoneEdge( f₋::T, f₊::T, Δx₋::T, Δx₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the derivative of a zone-centered variable, f, evaluated at the zone edge.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the value of ∂f/∂x evaluated at the boundary between two adjacent zones.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A zone-centered variable located in the zone to the (-) left or (+) right of the zone boundary at which the derivative is evaluated.</li><li><code>Δx</code>: The length of the zone to the (-) left or (+) right of the zone boundary at which the derivative is evaluated.</li></ul><p><strong>Notes</strong></p><p>The derivative is calculated using a first-order forward difference. Functionally,</p><pre><code class="nohighlight hljs">∂f/∂x[i+1/2] = ( f[i+1] - f[i] ) / ( xₘ[i+1] - xₘ[i] )</code></pre><p>where f is the zone-centered variable and xₘ is the coordinate of the center of the zone Since this code is Lagrangian, the location of zone edges is what is tracked, with the zone center computed as </p><pre><code class="nohighlight hljs">xₘ[i] = 0.5 * ( x[i-1/2] + x[i+1/2] )</code></pre><p>Therefore, the denominator above can be shown to be equivalent to</p><pre><code class="nohighlight hljs">xₘ[i+1] - xₘ[i] = 0.5 * ( x[i+3/2] + x[i+1/2] ) - 0.5 * ( x[i+1/2] + x[i-1/2] )

                = 0.5 * ( x[i+3/2] - x[i+1/2] ) + 0.5 * ( x[i+1/2] - x[i-1/2] )

                = 0.5 * Δx[i+1] + 0.5 * Δx[i]

                = 0.5 * ( Δx[i+1] + Δx[i] )</code></pre><p>and thus the derivative can be expressed as</p><pre><code class="nohighlight hljs">∂f/∂x = 2.0 * ( f[i+1] - f[i] ) / ( Δx[i+1] + Δx[i] )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/SpatialDerivatives.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.∂∂x_ZoneCenterToZoneCenter" href="#Euler1D.∂∂x_ZoneCenterToZoneCenter"><code>Euler1D.∂∂x_ZoneCenterToZoneCenter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∂∂x_ZoneCenterToZoneCenter( f₋::T, f::T, f₊::T, Δx₋::T, Δx::T, Δx₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Compute the derivative of a zone-centered variable, f, evaluated at the zone center.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the value of ∂f/∂x evaluated at the center of a zone.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The value of the zone centered variable to the (-) left or (+) right of the (0) current zone.</li><li><code>Δx</code>: The length of the zone to the (-) left or (+) right of the (0) current zone.</li></ul><p><strong>Notes</strong></p><p>This derivative is calculated by first linearly interpolating the zone-centered variables to the left and right zone boundaries of the current zone. These interpolated values are then used to evaluate the derivative at the zone center. The interpolated value at the left hand side of the zone is (where xₘ is the midpoint of the zone):</p><pre><code class="nohighlight hljs">f[i-1/2]    = f[i] + ∂f/∂x[i-1/2] * ( x[i-1/2] - xₘ[i] )

            = f[i] + ∂f/∂x[i-1/2] * ( x[i-1/2] - 0.5 * ( x[i+1/2] + x[i-1/2] ) )

            = f[i] + ∂f/∂x[i-1/2] * 0.5 * ( x[i-1/2] - x[i+1/2] )

            = f[i] - 0.5 * ∂f/∂x[i-1/2] * Δx[i]</code></pre><p>And similarly for the right hand side of the zone:</p><pre><code class="nohighlight hljs">f[i+1/2]    = f[i] + ∂f/∂x[i+1/2] * ( x[i+1/2] - xₘ[i] )

            = f[i] + ∂f/∂x[i+1/2] * ( x[i+1/2] - 0.5 * ( x[i+1/2] + x[i-1/2] ) )

            = f[i] + ∂f/∂x[i-1/2] * 0.5 * ( x[i+1/2] - x[i-1/2] )

            = f[i] + 0.5 * ∂f/∂x[i-1/2] * Δx[i]</code></pre><p>In both cases, <code>∂f/∂x[i+1/2]</code> (or <code>i-1/2</code>) can be evaluated using <a href="#Euler1D.∂∂x_ZoneEdgeToZoneEdge"><code>∂∂x_ZoneEdgeToZoneEdge()</code></a>. The derivative is then:</p><pre><code class="nohighlight hljs">∂f/∂x[i]    = ( f[i+1/2] - f[i-1/2] ) / ( x[i+1/2] - x[i-1/2] )</code></pre><div class="admonition is-warning" id="Warning-e5c4829f0e680b65"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-e5c4829f0e680b65" title="Permalink"></a></header><div class="admonition-body"><p>This function is not currently used by this package and is mainly included for completeness. As such, it is not well-tested and should be used with caution.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/SpatialDerivatives.jl#L41-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.∂∂x_ZoneEdgeToZoneCenter" href="#Euler1D.∂∂x_ZoneEdgeToZoneCenter"><code>Euler1D.∂∂x_ZoneEdgeToZoneCenter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∂∂x_ZoneEdgeToZoneCenter( f₋::T, f₊::T, Δx::T ) where { T &lt;: AbstractFloat }</code></pre><p>Evaluate the derivative of an edge-centered variable, f, at the center of the zone bounded by the two edges.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the value of ∂f/∂x evaluated at the center of a zone.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The value of the edge-centered variable at the (-) left or (+) right edge of the zone.</li><li><code>Δx</code>: The length of the zone.</li></ul><p><strong>Notes</strong></p><p>This is computed using a simple forward difference with the values at the left and right edges of the zone.</p><pre><code class="nohighlight hljs">∂f/∂x[i]    = ( f[i+1/2] - f[i-1/2] ) / ( x[i+1/2] - x[i-1/2] )

            = ( f[i+1/2] - f[i-1/2] ) / Δx[i]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/SpatialDerivatives.jl#L91-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Euler1D.∂∂x_ZoneEdgeToZoneEdge" href="#Euler1D.∂∂x_ZoneEdgeToZoneEdge"><code>Euler1D.∂∂x_ZoneEdgeToZoneEdge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∂∂x_ZoneEdgeToZoneEdge( f₋::T, f::T, f₊::T, Δx₋::T, Δx₊::T ) where { T &lt;: AbstractFloat }</code></pre><p>Computes the derivative of an edge-centered variable, f, at the zone edge.</p><p><strong>Returns</strong></p><p>A scalar of type <code>T</code> representing the value of ∂f/∂x</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The edge-centered variable to be evaluated. Subscripts refer to the zone edge to the (-) left or (+) right of the central (0) zone edge at which the derivative will be evaluated.</li><li><code>Δx</code>: The size of the zones to the (-) left or (+) right of the central zone edge.</li></ul><p><strong>Notes</strong></p><p>This function uses the values of the edge-centered variables to the (-) left and (+) right of the (0) central zone edge.  These left and right values are used to interpolate the edge centered values to the center of the zone to the (-,0) left or (0,+) right of the central zone edge. These interpolation steps are performed according to:</p><pre><code class="nohighlight hljs">f[i+1]  = f[i+1/2] + ∂f/∂x[i+1] * ( xₘ[i+1] - x[i+1/2] )

        = f[i+1/2] + ∂f/∂x[i+1] * ( 0.5 * ( x[i+3/2] + x[i+1/2] ) - x[i+1/2] )

        = f[i+1/2] + ∂f/∂x[i+1] * 0.5 * ( x[i+3/2] - x[i+1/2] )

        = f[i+1/2] + 0.5 * ∂f/∂x[i+1] * Δx[i+1]</code></pre><p>Similarly for the evaluation to the left:</p><pre><code class="nohighlight hljs">f[i]    = f[i+1/2] + ∂f/∂x[i] * ( xₘ[i] - x[i+1/2] )

        = f[i+1/2] + ∂f/∂x[i] * ( 0.5 * ( x[i+1/2] + x[i-1/2] ) - x[i+1/2] )

        = f[i+1/2] + ∂f/∂x[i] * 0.5 * ( x[i-1/2] - x[i+1/2] )

        = f[i+1/2] - 0.5 * ∂f/∂x[i] * Δx[i]</code></pre><p>The calculation of <code>∂f/∂x</code> is performed using <a href="#Euler1D.∂∂x_ZoneEdgeToZoneCenter"><code>∂∂x_ZoneEdgeToZoneCenter()</code></a>. The derivative evaluated at the central zone edge is therefore</p><pre><code class="nohighlight hljs">∂f/dx[i+1/2]    = ( f[i+1] - f[i] ) / ( xₘ[i+1] - xₘ[i] )

                = ( f[i+1] - f[i] ) / ( 0.5 * ( x[i+3/2] + x[i+1/2] ) - 0.5 * ( x[i+1/2] + x[i-1/2] ) )

                = 2.0 * ( f[i+1] - f[i] ) / ( ( x[i+3/2] - x[i+1/2] ) + ( x[i+1/2] - x[i-1/2] ) )

                = 2.0 * ( f[i+1] - f[i] ) / ( Δx[i+1] + Δx[i] )</code></pre><div class="admonition is-warning" id="Warning-e5c4829f0e680b65"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-e5c4829f0e680b65" title="Permalink"></a></header><div class="admonition-body"><p>This function is not currently used by this package and is mainly included for completeness. As such, it is not well-tested and should be used with caution.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fergu/Euler1D.jl/blob/845ef97a13df0c48e2b453fa9687b8c95f44a90c/src/SpatialDerivatives.jl#L114-L161">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Methodology/">« Methodology</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 1 August 2025 18:07">Friday 1 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
